"""Tools to analyze the results of vae learning and latent space computing."""


from pinchon_hoggan_dense import rot_mat, Jd
from ai import cs
from scipy.spatial.transform import Rotation as R
import importlib
import numpy as np
import pandas as pd
from sklearn.decomposition import PCA
import torch

import train_utils
import cryo_dataset

CUDA = torch.cuda.is_available()
DEVICE = torch.device("cuda" if CUDA else "cpu")

N_PCA_COMPONENTS = 5


def reload_libs():
    import from_vae_to_latent_space
    importlib.reload(from_vae_to_latent_space)
    import cryo_dataset
    importlib.reload(cryo_dataset)
    import visualization
    importlib.reload(visualization)
    import nn
    importlib.reload(nn)
    import train_utils
    importlib.reload(train_utils)


def pca_projection(mus, n_pca_components=N_PCA_COMPONENTS):
    pca = PCA(n_components=n_pca_components)
    pca.fit(mus)
    projected_mus = pca.transform(mus)
    return pca, projected_mus


def latent_projection(output, path_vae_param, dataset_path,
                      epoch_id=None):
    ckpt = train_utils.load_checkpoint(
        output=output, epoch_id=epoch_id)
    config = ckpt['nn_architecture']
    if "is_3d" not in config.keys():
        config["is_3d"] = True
    dataset = cryo_dataset.open_dataset(
        dataset_path, size=config["img_shape"][-1], is_3d=config["is_3d"])
    encoder = train_utils.load_module(
        output, path_vae_param, module_name='encoder', epoch_id=epoch_id)
    mus, logvar, z, matrix = encoder(dataset)
    return z.detach().numpy()


def vae_matrix(output, path_vae_param, dataset_path,
               epoch_id=None):
    ckpt = train_utils.load_checkpoint(
        output=output, epoch_id=epoch_id)
    config = ckpt['nn_architecture']
    dataset = cryo_dataset.open_dataset(
        dataset_path, size=config["img_shape"][-1], is_3d=config["is_3d"])
    encoder = train_utils.load_module(
        output, path_vae_param, module_name='encoder', epoch_id=epoch_id)
    mus, logvar, z, matrix = encoder(dataset)
    return matrix.detach().numpy()


def from_image_to_image(output, path_vae_param, dataset_path, n_img, epoch_id=None):
    ckpt = train_utils.load_checkpoint(
        output=output, epoch_id=epoch_id)
    config = ckpt['nn_architecture']
    if "is_3d" not in config.keys():
        config["is_3d"] = True
    encoder = train_utils.load_module(
        output, path_vae_param, module_name='encoder', epoch_id=epoch_id)
    decoder = train_utils.load_module(
        output, path_vae_param, module_name='decoder', epoch_id=epoch_id)
    dataset = cryo_dataset.open_dataset(
        dataset_path, size=config["img_shape"][-1], is_3d=config["is_3d"])
    dataset = dataset[:20]
    mus, logvar, z, matrix = encoder(dataset)
    recon, scale_b = decoder(z)
    return recon


def get_cryo_labels(labels_path=None, from_id=1, to_id=None):
    labels = {}
    labels['focus'] = []
    labels['theta'] = []
    if labels_path is not None:
        labels = pd.read_csv(labels_path)
        for column in labels.columns:
            labels[column] = labels[column].astype(float)
        # labels['rotation_x'] = labels['rotation_x'].astype(float)
        # labels['rotation_y'] = labels['rotation_y'].astype(float)
        # labels['rotation_z'] = labels['rotation_z'].astype(float)
        # labels['focus'] = labels['focus'].astype(float)
    return labels


def get_cryo(output, path_vae_param, dataset_path,
             labels_path=None, n_pca_components=2, epoch_id=None):

    labels = get_cryo_labels(labels_path)
    mus = latent_projection(
        output, path_vae_param, dataset_path, epoch_id)
    print(mus.shape)
    _, projected_mus = pca_projection(
        mus=mus, n_pca_components=n_pca_components)

    # return projected_mus, labels
    return mus, labels


def f(x):
    if x == 0:
        return -1
    else:
        return


def rot_matrix(labels_path):
    Coords = pd.read_csv(labels_path)
    real_matrix = pd.DataFrame(Coords.apply(lambda row: R.from_quat(
        [row['quat_x'], row['quat_y'], row['quat_z'], row['quat_w']]).as_matrix(), axis=1))
    return real_matrix


def prediction_rotation(output, path_vae_param, dataset_path, labels_path):
    J = Jd[1]
    ckpt = train_utils.load_checkpoint(output=output)
    config = ckpt['nn_architecture']
    real_matrix = rot_matrix(labels_path)
    real_matrix.columns = ['RMatrix']
    real_matrix = np.asarray(real_matrix['RMatrix'])
    if config["latent_space_definition"] == 0:
        vae_matrices = latent_projection(output, path_vae_param, dataset_path)
        n = len(vae_matrices)
        vae_matrix1 = []
        for i in range(n):
            vae_matrix1.append(R.from_rotvec(vae_matrices[i]).as_matrix())

    else:
        vae_matrix1 = vae_matrix(output, path_vae_param,
                                 dataset_path, epoch_id=None)
    vae_R0 = []
    n = len(vae_matrix1)
    for i in range(n):
        vae_R0.append(np.asarray(vae_matrix1[i]).dot(real_matrix[i]))
    grown_truth = []
    for i in range(n):
        grown_truth.append(R.from_matrix(vae_R0[i]).as_rotvec())
    new_rot = []
    for i in range(n):
        rot = np.linalg.norm(grown_truth[i])
        new_rot.append([rot, grown_truth[i]/rot])
    new_rot = pd.DataFrame(new_rot)
    new_rotvec = pd.DataFrame(new_rot[1][0]).T
    new_rotvec.columns = ['vec_x', 'vec_y', 'vec_z']
    for i in range(1, n):
        new1 = pd.DataFrame(new_rot[1][i]).T
        new1.columns = ['vec_x', 'vec_y', 'vec_z']
        new_rotvec = new_rotvec.append(new1.copy(), ignore_index=True)
    new_rotvec['rotation'] = new_rot[0]

    return grown_truth, vae_R0, new_rotvec
