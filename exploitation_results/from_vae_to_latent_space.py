"""Tools to analyze the results of vae learning and latent space computing."""

import importlib

import cryo_dataset
import nn
import numpy as np
import pandas as pd
import torch
import train_utils
import visualization
from scipy.spatial.transform import Rotation as R
from sklearn.decomposition import PCA

CUDA = torch.cuda.is_available()
DEVICE = torch.device("cuda" if CUDA else "cpu")

N_PCA_COMPONENTS = 5


def reload_libs():
    import from_vae_to_latent_space

    importlib.reload(from_vae_to_latent_space)
    importlib.reload(cryo_dataset)
    importlib.reload(visualization)
    importlib.reload(nn)
    importlib.reload(train_utils)


def pca_projection(mus, n_pca_components=N_PCA_COMPONENTS):
    pca = PCA(n_components=n_pca_components)
    pca.fit(mus)
    projected_mus = pca.transform(mus)
    return pca, projected_mus


def latent_projection(output, path_vae_param, dataset_path, epoch_id=None):
    ckpt = train_utils.load_checkpoint(output=output, epoch_id=epoch_id)
    config = ckpt["nn_architecture"]
    if "is_3d" not in config.keys():
        config["is_3d"] = True
    dataset = cryo_dataset.open_dataset(
        dataset_path, size=config["img_shape"][-1], is_3d=config["is_3d"]
    )
    encoder = train_utils.load_module(
        output, path_vae_param, module_name="encoder", epoch_id=epoch_id
    )
    mus, logvar, z, matrix = encoder(dataset)
    return z.detach().numpy()


def vae_matrix(output, path_vae_param, dataset_path, epoch_id=None):
    ckpt = train_utils.load_checkpoint(output=output, epoch_id=epoch_id)
    config = ckpt["nn_architecture"]
    dataset = cryo_dataset.open_dataset(
        dataset_path, size=config["img_shape"][-1], is_3d=config["is_3d"]
    )
    encoder = train_utils.load_module(
        output, path_vae_param, module_name="encoder", epoch_id=epoch_id
    )
    mus, logvar, z, matrix = encoder(dataset)
    return mus.detach().numpy(), z.detach().numpy(), matrix.detach().numpy()


def from_image_to_image(output, path_vae_param, dataset_path, n_img, epoch_id=None):
    ckpt = train_utils.load_checkpoint(output=output, epoch_id=epoch_id)
    config = ckpt["nn_architecture"]
    if "is_3d" not in config.keys():
        config["is_3d"] = True
    encoder = train_utils.load_module(
        output, path_vae_param, module_name="encoder", epoch_id=epoch_id
    )
    decoder = train_utils.load_module(
        output, path_vae_param, module_name="decoder", epoch_id=epoch_id
    )
    dataset = cryo_dataset.open_dataset(
        dataset_path, size=config["img_shape"][-1], is_3d=config["is_3d"]
    )
    dataset = dataset[:20]
    mus, logvar, z, matrix = encoder(dataset)
    recon, scale_b = decoder(z)
    return recon


def get_cryo_labels(labels_path=None, from_id=1, to_id=None):
    labels = {}
    labels["focus"] = []
    labels["theta"] = []
    if labels_path is not None:
        rotations, rotvec, labels, euler = cryo_dataset.open_labels(labels_path)
    return rotations, rotvec, labels, euler


def get_cryo(
    output,
    path_vae_param,
    dataset_path,
    labels_path=None,
    n_pca_components=2,
    epoch_id=None,
):

    rotations, rotvec, labels, euler = get_cryo_labels(labels_path)
    mus = latent_projection(output, path_vae_param, dataset_path, epoch_id)
    print(mus.shape)
    _, projected_mus = pca_projection(mus=mus, n_pca_components=n_pca_components)

    # return projected_mus, labels
    return mus, rotations, rotvec, labels, euler


def f(x):
    if x == 0:
        return -1
    else:
        return


def rot_matrix(labels_path):
    Coords = pd.read_csv(labels_path)
    real_matrix = pd.DataFrame(
        Coords.apply(
            lambda row: R.from_quat(
                [row["quat_x"], row["quat_y"], row["quat_z"], row["quat_w"]]
            ).as_matrix(),
            axis=1,
        )
    )
    return real_matrix


def prediction_rotation(output, path_vae_param, dataset_path, labels_path):
    ckpt = train_utils.load_checkpoint(output=output)
    config = ckpt["nn_architecture"]
    real_matrix = np.load(labels_path)
    if config["latent_space_definition"] == 0:
        vae_matrices = latent_projection(output, path_vae_param, dataset_path)
        n = len(vae_matrices)
        vae_matrix1 = []
        for i in range(n):
            vae_matrix1.append(R.from_rotvec(vae_matrices[i]).as_matrix())

    else:
        mus, z, matrix = vae_matrix(output, path_vae_param, dataset_path)
        matrix_from_mus = nn.rot_mat_tensor(mus, 3)
        with_mus = compute_ground_truth(real_matrix, matrix_from_mus)
        with_matrix = compute_ground_truth(real_matrix, matrix)
    return with_mus, with_matrix


def compute_ground_truth(real_matrix, estimate_matrix):
    vae_R0 = []
    n = len(estimate_matrix)
    for i in range(n):
        vae_R0.append(np.asarray(estimate_matrix[i]).dot(real_matrix[i].T))
    ground_truth = []
    for i in range(n):
        ground_truth.append(R.from_matrix(vae_R0[i]).as_rotvec())
    new_rot = []
    for i in range(n):
        rot = np.linalg.norm(ground_truth[i])
        new_rot.append([rot, ground_truth[i] / rot])
    new_rot = pd.DataFrame(new_rot)
    new_rotvec = pd.DataFrame(new_rot[1][0]).T
    new_rotvec.columns = ["vec_x", "vec_y", "vec_z"]
    for i in range(1, n):
        new1 = pd.DataFrame(new_rot[1][i]).T
        new1.columns = ["vec_x", "vec_y", "vec_z"]
        new_rotvec = new_rotvec.append(new1.copy(), ignore_index=True)
    new_rotvec["rotation"] = new_rot[0]

    return vae_R0, ground_truth, new_rotvec
